options{ LOOKAHEAD=1;}

PARSER_BEGIN(Autoanalyze)
public class Autoanalyze{
	public static void main(String[] args) throws ParseException{
		try{
			Autoanalyze tree = new Autoanalyze(System.in);
			tree.Start();
			System.out.println("accept");
		}catch(Exception e){System.out.println("reject");}
	}
}
PARSER_END(Autoanalyze)

SKIP:{" "|"\r"|"\t"|"\n"}

TOKEN:{	
< START : ("{") >|									//begin
< FINISH : ("}") >|									//end
< VAR: (["A"-"Z"])(["A"-"Z","a"-"z","0"-"9"]|"_")* >|	//variable name (must start with a capital letter)
< ASSIGN: ("=") >|									//variable assignement
< CART: ("*") >|									//cartesian product
< INTR: ("&") >|									//intersection
< CMPL: ("~") >|									//complement
< UNI: ("+") >|										//union
< DIF: ("-") >|										//difference
< OPEN: ("(") >|									//open parenthesis
< CLOSE: (")") >|									//close parenthesis
< END: (";") >|										//end statement
< COMMA: (",") >|									//comma
< READ: ("read")>|									//read(PATH) returns a automata from the dotty file in PATH
< WRITE: ("write") >|								//write(VAR,PATH) writes VAR into a dotty file in PATH
< COMP: ("compare")>|								//compare(VAR,VAR) finds the  relational operator R so that VAR R VAR is true R€{==,!=,€}
< TEST: ("test") >|									//test(VAR,PATH) tests every word in the PATH file with the VAR automata
< REGX: ("regex") >|								//regex(VAR) return a regular expression with the same language as VAR
< PATH: (["A"-"Z","a"-"z","0"-"9","/"])*(["A"-"Z","a"-"z","0"-"9"])+ ("."(["A"-"Z","a"-"z","0"-"9"])+)? >//path to file
}

SimpleNode Start():{}{<START>Stmt()<FINISH>{return jjtThis;}}

void Stmt():{Token t;}{(Assign())? (Expr() | Function()) t=<END> (Stmt())?}

void Assign():{Token var,eq;}{var=<VAR> eq=<ASSIGN>}

void Expr():{Token op1,op2,op;}{op1=<VAR> ((op=<CART>|op=<INTR>|op=<CMPL>|op=<UNI>|op=<DIF>) Expr())?}

void Function():{}{(FuncRead() | FuncWrite() | FuncComp() | FuncTest() | FuncRegex())}

void FuncRead():{Token func,path;}{func=<READ> <OPEN> path=<PATH> <CLOSE>}

void FuncWrite():{Token func,var,path;}{func=<WRITE> <OPEN> var=<VAR> <COMMA> path=<PATH> <CLOSE>}

void FuncComp():{Token func,var1,var2;}{func=<COMP> <OPEN> var1=<VAR> <COMMA> var2=<VAR> <CLOSE>}

void FuncTest():{Token func,var,path;}{func=<TEST> <OPEN> var=<VAR> <COMMA> path=<PATH> <CLOSE>}

void FuncRegex():{Token func,var;}{func=<REGX> <OPEN> var=<VAR> <CLOSE>}